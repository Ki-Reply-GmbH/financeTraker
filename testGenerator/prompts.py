
from langchain.prompts.chat import ChatPromptTemplate
from langchain_core.messages import SystemMessage
from langchain_core.prompts import HumanMessagePromptTemplate
from langchain import PromptTemplate

def setup_test_generation_case_prompt():
    test_case_generation_prompt_template = """You are tasked with generating a clear and concise description of a function and corresponding unit tests. /
                                           The procedure is given in the Description Phase and the Unit Test Generation Phase. Follow them sequentially: /
 
        ###Unit Test Generation Phase:###
 
        Based on the initial description, craft corresponding unit tests from the Human Message.
        Utilize pytest and mocker for data-driven testing.
        Structure the tests with clear Given blocks to enhance test coverage and support robust system development.
        Include unit test code and inline documentation explaining the test purpose and logic.
        Use mocks to simulate external dependencies accurately.
 
        ###Important Instructions:###
 
        In your response, follow the exact format shown in the example below.
        Escape all special characters in the code (e.g., double quotes, single quotes, new lines) with a backslash.
        Make sure to include the appropriate import statements for the function and its dependencies.
 
        Example:
 
        Example: 
        {
            "function_description": "GENERATED DESCRIPTION HERE",
            "code": "GENERATED CODE HERE"
        } 
 
        sample User Input: input is defined in Human Message.
 
        sample LLM Response:
 
        {
            "function_description": "This function registers a new user. It takes a single input `user` of type `UserCreate`, attempts to create the user, and returns a success message. If an error occurs, it logs the error and raises an HTTP 500 exception.",
            "code": "import pytest\\n\\nasync def test_register_user(mocker):\\n\\t# Given\\n\\tuser_create_instance = UserCreate(username=\\\"testuser\\\", password=\\\"testpassword\\\")\\n\\tmock_create_user = mocker.patch('path.to.create_user')\\n\\tmock_logger = mocker.patch('path.to.logger.error')\\n\\tmock_http_exception = mocker.patch('path.to.HTTPException')\\n\\n\\t# When\\n\\tresponse = await register_user(user_create_instance)\\n\\n\\t# Then\\n\\tmock_create_user.assert_called_once_with(user_create_instance)\\n\\tassert response == {\\\"message\\\": \\\"User registered successfully\\\"}\\n\\n\\t# When Exception Occurs\\n\\tmock_create_user.side_effect = Exception(\\\"Error\\\")\\n\\twith pytest.raises(HTTPException) as exc_info:\\n\\t\\tawait register_user(user_create_instance)\\n\\tmock_logger.assert_called_once()\\n\\tassert exc_info.value.status_code == 500\\n\\tassert exc_info.value.detail == \\\"Error registering user\\\""
        }
    """

    prompt = ChatPromptTemplate.from_messages(
        [
            SystemMessage(content=test_case_generation_prompt_template),
            HumanMessagePromptTemplate.from_template("{input}"),
        ]
    )
    
    

    return prompt


def setup_test_generation_case_fewshot_prompt():
    
    test_case_generation_fewshot_prompt_template = """ You are tasked with generating a clear and concise description of a function and corresponding unit tests. /
                                                   The procedure is given in the *** Unit Test Generation Phase *** and *** Important Instructions:*** . Follow  /
                                                   them sequentially: /
 
    ###Unit Test Generation Phase:###
 
        - Based on the initial description, craft corresponding unit tests from the Human Message.
        - Utilize pytest and mocker for data-driven testing.
        - Structure the tests with clear Given blocks to enhance test coverage and support robust system development.
        - Include unit test code and inline documentation explaining the test purpose and logic.
        - Use mocks to simulate external dependencies accurately.
 
    ###Important Instructions:###
 
        In your response, follow the exact format shown in the ### Examples ### below. Analyze both examples where:
        
        - commoncode : is the code segment which is common in differnt files and differnt functions as well.
        - test1 : is the first test code which has to be precisely generated by you the given function.
        - test2 : is the second test code which has to be precisely generated by you for the given function.
        
        Also you can add additional test code like test3 , test4 if you think it is necessary.
        
        Escape all special characters in the code (e.g., double quotes, single quotes, new lines) with a backslash.
        Make sure to include the appropriate import statements for the function and its dependencies.
 
        Example:
 
    ### Examples ###

    *** Example 1 ***
    
    {
        "commoncode": "\nimport pytest\nfrom app.services.user_services import get_user\nfrom app.models.models import User, get_db\nfrom unittest.mock import MagicMock\n\n@pytest.fixture\ndef mock_user():\n    return User(email='test@example.com', name='Test User')\n\n@pytest.fixture\ndef mock_db_session(mocker):\n    mock_session = mocker.MagicMock()\n    mock_query = mocker.MagicMock()\n    mock_session.query.return_value = mock_query\n    mock_query.filter.return_value = mock_query\n    mocker.patch('app.models.models.get_db', return_value=mock_session)\n    return mock_session\n",
    
        "test1": "\ndef test_get_user_found(mocker, mock_db_session, mock_user):\n    # Given\n    mock_db_session.query.return_value.filter.return_value.first.return_value = mock_user\n\n    # When\n    result = get_user('test@example.com')\n\n    # Then\n    assert result == mock_user\n    mock_db_session.query.assert_called_once_with(User)\n    mock_db_session.query.return_value.filter.assert_called_once_with(User.email == 'test@example.com')\n",
    
        "test2": "\ndef test_get_user_not_found(mocker, mock_db_session):\n    # Given\n    mock_db_session.query.return_value.filter.return_value.first.return_value = None\n\n    # When\n    result = get_user('notfound@example.com')\n\n    # Then\n    assert result is None\n    mock_db_session.query.assert_called_once_with(User)\n    mock_db_session.query.return_value.filter.assert_called_once_with(User.email == 'notfound@example.com')\n"
    }


    *** Example 2 ***
    {
        "commoncode": "\nimport pytest\nfrom app.services.user_services import get_user\nfrom app.models.models import User, get_db\nfrom unittest.mock import MagicMock\n\n@pytest.fixture\ndef mock_user():\n    return User(email='test@example.com', name='Test User')\n\n@pytest.fixture\ndef mock_db_session(mocker):\n    mock_session = mocker.MagicMock()\n    mock_query = mocker.MagicMock()\n    mock_session.query.return_value = mock_query\n    mock_query.filter.return_value = mock_query\n    mocker.patch('app.models.models.get_db', return_value=mock_session)\n    return mock_session\n",
    
        "test1": "\ndef test_get_user_found(mocker, mock_db_session, mock_user):\n    # Given\n    mock_db_session.query.return_value.filter.return_value.first.return_value = mock_user\n\n    # When\n    result = get_user('test@example.com')\n\n    # Then\n    assert result == mock_user\n    mock_db_session.query.assert_called_once_with(User)\n    mock_db_session.query.return_value.filter.assert_called_once_with(User.email == 'test@example.com')\n",
    
        "test2": "\ndef test_get_user_not_found(mocker, mock_db_session):\n    # Given\n    mock_db_session.query.return_value.filter.return_value.first.return_value = None\n\n    # When\n    result = get_user('notfound@example.com')\n\n    # Then\n    assert result is None\n    mock_db_session.query.assert_called_once_with(User)\n    mock_db_session.query.return_value.filter.assert_called_once_with(User.email == 'notfound@example.com')\n"
    }

 
    sample User Input: input is defined in Human Message.
 
    sample LLM Response:
 
    {
        "commoncode": Generate the common code snippet,
        "test1" : Generate the first test code,
        "test2" : Generate the second test code 
            
    }
    """

    prompt = ChatPromptTemplate.from_messages(
        [
            SystemMessage(content=test_case_generation_fewshot_prompt_template),
            HumanMessagePromptTemplate.from_template("{input}"),
        ]
    )
    
    return prompt



def setup_self_healing_prompt_template():
    self_healing_prompt_template = """
    You are tasked with debugging failing unit tests. Below is the information required:

    Function Code: This is the original code of the function being tested.
    Test Code: This is the generated unit test code.
    Test Run Output: This includes the error messages and traceback from running the tests.

    Function Code:{function_code}
    Test Code:{test_code}
    Test Run Output:{test_run_output}
    
    ### Instructions:
    Analyze the provided function code, test code, and test run output.
    Identify the root cause of the test failures.
    Regenerate the corrected unit test code if necessary.
    Your response must be structured as shown in the example below.

    {
        "corrected_code": "CORRECTED CODE HERE"
    }
    """

    prompt = ChatPromptTemplate.from_messages(
        [
            SystemMessage(content=self_healing_prompt_template),
            HumanMessagePromptTemplate.from_template("{input}"),
        ]
    )

    return prompt

